#!/usr/bin/env python
# coding=utf-8

import dbus
import math
import os
import re
import subprocess
import subprocess as sp
import sys
import time
from argparse import ArgumentParser
from configparser import ConfigParser


DBUS = 'qdbus org.kde.yakuake '

bus = dbus.SessionBus()


class SortedDict(dict):
    def __init__(self, *args, **kwargs):
        dict.__init__(self, *args, **kwargs)
        self.keyOrder = list(dict.keys(self))

    def keys(self):
        return self.keyOrder

    def iterkeys(self):
        for key in self.keyOrder:
            yield key

    __iter__ = iterkeys

    def items(self):
        return [(key, self[key]) for key in self.keyOrder]

    def iteritems(self):
        for key in self.keyOrder:
            yield (key, self[key])

    def values(self):
        return [self[key] for key in self.keyOrder]

    def itervalues(self):
        for key in self.keyOrder:
            yield self[key]

    def __setitem__(self, key, val):
        self.keyOrder.append(key)
        dict.__setitem__(self, key, val)

    def __delitem__(self, key):
        self.keyOrder.remove(key)
        dict.__delitem__(self, key)


def get_stdout(cmd, **opts):
    opts.update({'stdout': sp.PIPE})
    if 'env' in opts:
        env, opts['env'] = opts['env'], os.environ.copy()
        opts['env'].update(env)

    quoted = re.findall(r'".+"', cmd)
    for q in quoted:
        cmd = cmd.replace(q, '%s')

    cmd_split = cmd.split()
    for i, part in enumerate(cmd_split):
        if part == '%s':
            cmd_split[i] = quoted.pop(0)[1:-1]

    proc = subprocess.Popen(cmd_split, **opts)
    return proc.communicate()[0].decode('utf-8').strip()


def get_yakuake(cmd):
    return get_stdout(DBUS + cmd)


def get_sessions():
    tabs = []
    activesess = int(get_yakuake('/yakuake/sessions activeSessionId'))

    ksessions = sorted(
        int(line.split('/')[-1])
        for line in get_yakuake('').split('\n') if '/Sessions/' in line
    )
    last_tabid = None

    for ksession in ksessions:
        # Está dando la sesión del id en el que se hizo el split, no tiene nada que ver con el tab, pero ayuda.
        # Por ejemplo, sesión 4->split->sesión 5->split->sesión 6, dará sesión 5 para la sesión 6.
        # Al usar "sessionAtTab", me devuelve la primera sesión abierta en el tab, lo cual me ayuda a seguir
        # el orden.
        tabid = int(get_yakuake(
            '/yakuake/sessions sessionIdForTerminalId {}'.format(ksession - 1)
        ))

        split = '' if tabid != last_tabid \
            else ('vertical' if ksession % 2 else 'horizontal')

        last_tabid = tabid
        sessid = int(get_yakuake('/yakuake/tabs sessionAtTab {}'.format(tabid)))

        ksess = '/Sessions/{}'.format(ksession)
        pid = get_yakuake(ksess + ' processId')

        fgpid = get_yakuake(ksess + ' foregroundProcessId')
        tabs.append({
            'title': get_yakuake('/yakuake/tabs tabTitle {}'.format(tabid)),
            'sessionid': tabid,
            'tabid': tabid,
            'active': sessid == activesess,
            'split': split,
            'cwd': get_stdout('pwdx ' + pid).partition(' ')[2],
            'cmd': '' if fgpid == pid else
            get_stdout(
                'ps ' + fgpid,
                env={'PS_FORMAT': 'command'}
            ).split('\n')[-1],
        })

    return tabs


def format_sessions(tabs, fp):
    cp = ConfigParser(dict_type=SortedDict)
    tabpad = int(math.log10(len(tabs))) + 1

    for i, tab in enumerate(tabs):
        section = 'Tab {num:{fill}{width}}'.format(
            num=i + 1, fill='0', width=tabpad
        )

        cp.add_section(section)
        cp.set(section, 'title', tab['title'])
        cp.set(section, 'active', '1' if tab['active'] else '0')
        cp.set(section, 'tab', str(tab['tabid']))
        cp.set(section, 'split', tab['split'])
        cp.set(section, 'cwd', tab['cwd'])
        cp.set(section, 'cmd', tab['cmd'])
        
    cp.write(fp)


def load_sessions(file):
    cp = ConfigParser(dict_type=SortedDict)
    cp.read_file(file)

    sections = cp.sections()
    if not sections:
        print("No tab info found, aborting", file=sys.stderr)
        sys.exit(1)

    # Clear existing sessions
    subprocess.call(['killall', 'yakuake'])
    subprocess.call(['yakuake'])
    time.sleep(2)

    # Repopulate the tabs
    tab = 0
    active = 0
    for i, section in enumerate(sections):
        opts = dict(cp.items(section))
        if not opts['split']:
            tab += 1
            get_yakuake('/yakuake/sessions addSession')
            get_yakuake(
                '/yakuake/tabs setTabTitle {} "{}"'.format(tab, opts['title'])
            )
        else:
            target, split = (tab, opts['split']) if ':' not in opts['split'] \
                else opts['split'].split(':')

            get_yakuake('/yakuake/sessions splitTerminal{} {}'.format(
                {'vertical': 'LeftRight', 'horizontal': 'TopBottom'}[split],
                int(target)
            ))

        sessid = int(get_yakuake('/yakuake/tabs sessionAtTab {}'.format(i)))
        if opts['cwd']:
            get_yakuake(
                '/yakuake/sessions runCommand " cd {}"'.format(opts['cwd'])
            )

        if opts['cmd']:
            for cmd in opts['cmd'].split(r'\n'):
                dbus_session = bus.get_object(
                    'org.kde.yakuake',
                    '/Sessions/{}'.format(i + 1)
                )
                dbus_session = dbus.Interface(
                    dbus_session,
                    'org.kde.konsole.Session'
                )
                dbus_session.sendText(cmd)
                dbus_session.sendText('\n')

        if opts['active'].lower() in ['y', 'yes', 'true', '1']:
            active = sessid

    if active:
        get_yakuake('/yakuake/sessions raiseSession {}'.format(active))

    # Remove initial session
    get_yakuake('/yakuake/sessions removeSession 0')


def main():
    # TODO: also store shell environment (for virtualenvs and such)
    arg_parser = ArgumentParser(
        description="Save and load yakuake sessions. Settings are exported "
                    "in INI format. Default action is to print the current "
                    "setup to stdout in INI format."
    )

    group_exclusive = arg_parser.add_mutually_exclusive_group(required=True)

    group_exclusive.add_argument(
        '-i', '--in-file',
        help='File to read from, or "-" for stdin',
        dest='infile',
        metavar='FILE'
    )

    group_exclusive.add_argument(
        '-o', '--out-file',
        help='File to write to, or "-" for stdout',
        dest='outfile',
        metavar='FILE'
    )

    arg_parser.add_argument(
        '--force-overwrite',
        help='Do not prompt for confirmation if out-file exists',
        dest='force_overwrite',
        action="store_true",
        default=False
    )

    args = arg_parser.parse_args()

    if args.outfile is None and args.infile is None:
        format_sessions(get_sessions(), sys.stdout)
        return 0

    if args.infile is not None:
        if args.infile == '-':
            load_sessions(sys.stdin)
        elif os.path.exists(args.infile):
            file_path = open(args.infile, 'r')
            load_sessions(file_path)
        else:
            print("ERROR - Input file does not exist: '{}'".format(args.infile),
                  file=sys.stderr)
            return 1

        return 0

    if args.outfile is not None:
        if args.outfile == '-':
            format_sessions(get_sessions(), sys.stdout)
        elif not os.path.exists(args.outfile) or args.force_overwrite:
            file_path = open(args.outfile, 'w')
            format_sessions(get_sessions(), file_path)
        else:
            print("ERROR - File does already exist: '{}'".format(args.outfile),
                  file=sys.stderr)
            return 1

        return 0

    print("ERROR - Malformed arguments were passed.", file=sys.stderr)
    return 1


if __name__ == '__main__':
    sys.exit(main())
