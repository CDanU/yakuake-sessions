#!/usr/bin/env python
# coding=utf-8

import dbus
import os
import re
import subprocess
import sys
import time
from argparse import ArgumentParser
from configparser import ConfigParser
from enum import Enum


DBUS = 'qdbus org.kde.yakuake '

bus = dbus.SessionBus()


class Yakuake():
    __common_name = 'org.kde.yakuake'
    __konsole_name = 'org.kde.konsole'

    __konsole_session_interface_name = __konsole_name + ".Session"
    __konsole_window_interface_name = __konsole_name + ".Window"

    __introspection_interface_name = 'org.freedesktop.DBus.Introspectable'

    def __init__(self, *args, **kwargs):
        self.__bus = dbus.SessionBus()

        self.__sessions_object = self.__bus.get_object(
            self.__common_name, '/yakuake/sessions'
        )
        self.__sessions_interface = dbus.Interface(
            self.__sessions_object,  self.__common_name
        )

        self.__tabs_object = self.__bus.get_object(
            self.__common_name, '/yakuake/tabs'
        )
        self.__tabs_interface = dbus.Interface(
            self.__tabs_object, self.__common_name
        )

        self.__window_object = self.__bus.get_object(
            self.__common_name, '/yakuake/window'
        )
        self.__window_interface = dbus.Interface(
            self.__window_object, self.__common_name
        )

    @staticmethod
    def __split_number_string(string):
        splits = string.split(",")
        numbers = []
        for split in splits:
            numbers.append(int(split))
        return numbers

    @staticmethod
    def __split_number_string_array(string_array):
        numbers = []
        for string in string_array:
            numbers.append(int(string))
        return numbers

    def __terminal_id_to_konsole_session_id(self, terminal_id):
        konsole_window_object = self.__bus.get_object(
            self.__common_name, '/Windows/{}'.format(terminal_id + 1)
        )
        konsole_sessions = sorted(self.__split_number_string_array(
            konsole_window_object.sessionList(
                dbus_interface=self.__konsole_window_interface_name
            )
        ))
        if len(konsole_sessions) > 1:
            print("Warning: konsole terminal has more than one session open. "
                  "The last will be used returned.",
                  file=sys.stderr)

        return konsole_sessions[-1]

    def active_session_id(self):
        return self.__sessions_interface.activeSessionId()

    def active_terminal_id(self):
        return self.__sessions_interface.activeTerminalId()

    def add_session_quad(self):
        return self.__sessions_interface.addSessionQuad()

    def add_session_two_horizontal(self):
        return self.__sessions_interface.addSessionTwoHorizontal()

    def add_session_two_vertical(self):
        return self.__sessions_interface.addSessionTwoVertical()

    def add_session(self):
        return self.__sessions_interface.addSession()

    def has_terminals_with_keyboard_input_disabled(self, session_id):
        return self.__sessions_interface.hasTerminalsWithKeyboardInputDisabled(
            session_id
        )

    def has_terminals_with_keyboard_input_enabled(self, session_id):
        return self.__sessions_interface.hasTerminalsWithKeyboardInputEnabled(
            session_id
        )

    def has_terminals_with_monitor_activity_disabled(self, session_id):
        return self.__sessions_interface.hasTerminalsWithMonitorActivityDisabled(
            session_id
        )

    def has_terminals_with_monitor_activity_enabled(self, session_id):
        return self.__sessions_interface.hasTerminalsWithMonitorActivityEnabled(
            session_id
        )

    def has_terminals_with_monitor_silence_disabled(self, session_id):
        return self.__sessions_interface.hasTerminalsWithMonitorSilenceDisabled(
            session_id
        )

    def has_terminals_with_monitor_silence_enabled(self, session_id):
        return self.__sessions_interface.hasTerminalsWithMonitorSilenceEnabled(
            session_id
        )

    def has_unclosable_sessions(self):
        return self.__sessions_interface.hasUnclosableSessions()

    def is_session_closable(self, session_id):
        return bool(self.__sessions_interface.isSessionClosable(session_id))

    def is_session_keyboard_input_enabled(self, session_id):
        return bool(self.__sessions_interface.isSessionKeyboardInputEnabled(
            session_id))

    def is_session_monitor_activity_enabled(self, session_id):
        return bool(self.__sessions_interface.isSessionMonitorActivityEnabled(
            session_id))

    def is_session_monitor_silence_enabled(self, session_id):
        return bool(self.__sessions_interface.isSessionMonitorSilenceEnabled(
            session_id))

    def is_terminal_keyboard_input_enabled(self, terminal_id):
        return bool(self.__sessions_interface.isTerminalKeyboardInputEnabled(
            terminal_id))

    def is_terminal_monitor_activity_enabled(self, terminal_id):
        return bool(self.__sessions_interface.isTerminalMonitorActivityEnabled(
            terminal_id))

    def is_terminal_monitor_silence_enabled(self, terminal_id):
        return bool(self.__sessions_interface.isTerminalMonitorSilenceEnabled(
            terminal_id))

    def raise_session(self, session_id):
        self.__sessions_interface.raiseSession(session_id)

    def remove_session(self, session_id):
        self.__sessions_interface.removeSession(session_id)

    def remove_terminal(self, terminal_id):
        self.__sessions_interface.removeTerminal(terminal_id)

    def run_command_in_terminal(self, terminal_id, command):
        self.__sessions_interface.runCommandInTerminal(terminal_id, command)

    def run_command(self, command):
        self.__sessions_interface.runCommand(command)

    def session_id_for_terminal_id(self, terminal_id):
        return self.__sessions_interface.sessionIdForTerminalId(terminal_id)

    def session_id_list(self):
        return self.__split_number_string(
            self.__sessions_interface.sessionIdList()
        )

    def set_session(
            self,
            session_id,
            closable=None,
            keyboard_input_enabled=None,
            monitor_activity_enabled=None,
            monitor_silence_enabled=None
    ):
        if closable is not None:
            self.__sessions_interface.setSessionClosable(session_id, closable)
        if keyboard_input_enabled is not None:
            self.__sessions_interface.setSessionKeyboardInputEnabled(
                session_id,
                keyboard_input_enabled
            )
        if monitor_activity_enabled is not None:
            self.__sessions_interface.setSessionMonitorActivityEnabled(
                session_id,
                monitor_activity_enabled
            )
        if monitor_silence_enabled is not None:
            self.__sessions_interface.setSessionMonitorSilenceEnabled(
                session_id,
                monitor_silence_enabled
            )

    def set_terminal(
            self,
            terminal_id,
            keyboard_input_enabled=None,
            monitor_activity_enabled=None,
            monitor_silence_enabled=None
    ):
        if keyboard_input_enabled is not None:
            self.__sessions_interface.setTerminalKeyboardInputEnabled(
                terminal_id,
                keyboard_input_enabled
            )
        if monitor_activity_enabled is not None:
            self.__sessions_interface.setTerminalMonitorActivityEnabled(
                terminal_id,
                monitor_activity_enabled
            )
        if monitor_silence_enabled is not None:
            self.__sessions_interface.setTerminalMonitorSilenceEnabled(
                terminal_id,
                monitor_silence_enabled
            )

    class SplitType(Enum):
        No_Split = 0
        Left_Right = 1
        Top_Bottom = 2

    def split_session(self, session_id, split_type):
        if split_type == self.SplitType.Left_Right:
            return self.__sessions_interface.splitSessionLeftRight(session_id)
        elif split_type == self.SplitType.Top_Bottom:
            return self.__sessions_interface.splitSessionTopBottom(session_id)
        return -1

    def split_terminal(self, terminal_id, split_type):
        if split_type == self.SplitType.Left_Right:
            return self.__sessions_interface.splitTerminalLeftRight(terminal_id)
        elif split_type == self.SplitType.Top_Bottom:
            return self.__sessions_interface.splitTerminalTopBottom(terminal_id)
        return -1

    def terminal_id_list(self):
        return self.__split_number_string(
            self.__sessions_interface.terminalIdList()
        )

    def terminal_ids_for_session_id(self, session_id):
        return self.__split_number_string(
            self.__sessions_interface.terminalIdsForSessionId(session_id)
        )

    class Direction(Enum):
        Top = 1
        Right = 2
        Bottom = 3
        Left = 4

    def try_grow_terminal(self, terminal_id, direction, pixels=None):
        if direction == self.Direction.Top:
            if pixels is not None:
                return self.__sessions_interface.tryGrowTerminalTop(
                    terminal_id,
                    pixels
                )
            return self.__sessions_interface.tryGrowTerminalTop(terminal_id)
        if direction == self.Direction.Right:
            if pixels is not None:
                return self.__sessions_interface.tryGrowTerminalRight(
                    terminal_id,
                    pixels
                )
            return self.__sessions_interface.tryGrowTerminalRight(terminal_id)
        if direction == self.Direction.Bottom:
            if pixels is not None:
                return self.__sessions_interface.tryGrowTerminalBottom(
                    terminal_id,
                    pixels
                )

            return self.__sessions_interface.tryGrowTerminalBottom(terminal_id)
        if direction == self.Direction.Left:
            if pixels is not None:
                return self.__sessions_interface.tryGrowTerminalLeft(
                    terminal_id,
                    pixels
                )

            return self.__sessions_interface.tryGrowTerminalLeft(terminal_id)

        return -1

    def terminal_pid(self, terminal_id):
        konsole_session = self.__terminal_id_to_konsole_session_id(terminal_id)

        konsole_session_object = self.__bus.get_object(
            self.__common_name, '/Sessions/{}'.format(konsole_session)
        )
        return int(konsole_session_object.processId(
            dbus_interface=self.__konsole_session_interface_name
        ))

    def terminal_forground_pid(self, terminal_id):
        konsole_session = self.__terminal_id_to_konsole_session_id(terminal_id)

        konsole_session_object = self.__bus.get_object(
            self.__common_name, '/Sessions/{}'.format(konsole_session)
        )
        return int(konsole_session_object.foregroundProcessId(
            dbus_interface=self.__konsole_session_interface_name
        ))

    def terminal_send_text(self, terminal_id, text):
        konsole_session = self.__terminal_id_to_konsole_session_id(terminal_id)

        konsole_session_object = self.__bus.get_object(
            self.__common_name, '/Sessions/{}'.format(konsole_session)
        )
        konsole_session_object.sendText(
            text,
            dbus_interface=self.__konsole_session_interface_name
        )

    def session_at_tab(self, tab_index):
        return self.__tabs_interface.sessionAtTab(tab_index)

    def set_tab_title(self, session_id, tab_title):
        self.__tabs_interface.setTabTitle(session_id, tab_title)

    def tab_title(self, session_id):
        return self.__tabs_interface.tabTitle(session_id)

    def toggle_window_state(self):
        self.__window_interface.toggleWindowState()


class SortedDict(dict):
    def __init__(self, *args, **kwargs):
        dict.__init__(self, *args, **kwargs)
        self.keyOrder = list(dict.keys(self))

    def keys(self):
        return self.keyOrder

    def iterkeys(self):
        for key in self.keyOrder:
            yield key

    __iter__ = iterkeys

    def items(self):
        return [(key, self[key]) for key in self.keyOrder]

    def iteritems(self):
        for key in self.keyOrder:
            yield (key, self[key])

    def values(self):
        return [self[key] for key in self.keyOrder]

    def itervalues(self):
        for key in self.keyOrder:
            yield self[key]

    def __setitem__(self, key, val):
        self.keyOrder.append(key)
        dict.__setitem__(self, key, val)

    def __delitem__(self, key):
        self.keyOrder.remove(key)
        dict.__delitem__(self, key)


def get_stdout(cmd, **opts):
    opts.update({'stdout': subprocess.PIPE})
    if 'env' in opts:
        env, opts['env'] = opts['env'], os.environ.copy()
        opts['env'].update(env)

    quoted = re.findall(r'".+"', cmd)
    for q in quoted:
        cmd = cmd.replace(q, '%s')

    cmd_split = cmd.split()
    for i, part in enumerate(cmd_split):
        if part == '%s':
            cmd_split[i] = quoted.pop(0)[1:-1]

    proc = subprocess.Popen(cmd_split, **opts)
    return proc.communicate()[0].decode('utf-8').strip()


def get_yakuake(cmd):
    return get_stdout(DBUS + cmd)


def get_sessions():
    tabs = []
    active_sessionid = int(get_yakuake('/yakuake/sessions activeSessionId'))

    ksessions = sorted(
        int(line.split('/')[-1])
        for line in get_yakuake('').split('\n') if '/Sessions/' in line
    )
    last_tabid = None

    for ksession in ksessions:
        # Está dando la sesión del id en el que se hizo el split, no tiene nada que ver con el tab, pero ayuda.
        # Por ejemplo, sesión 4->split->sesión 5->split->sesión 6, dará sesión 5 para la sesión 6.
        # Al usar "sessionAtTab", me devuelve la primera sesión abierta en el tab, lo cual me ayuda a seguir
        # el orden.
        tabid = int(get_yakuake(
            '/yakuake/sessions sessionIdForTerminalId {}'.format(ksession - 1)
        ))

        sessid = int(get_yakuake('/yakuake/tabs sessionAtTab {}'.format(tabid)))
        tab_title = get_yakuake('/yakuake/tabs tabTitle {}'.format(tabid)),

        split = '' if tabid != last_tabid \
            else ('vertical' if ksession % 2 else 'horizontal')
        last_tabid = tabid

        ksess = '/Sessions/{}'.format(ksession)

        pid = get_yakuake(ksess + ' processId')
        fgpid = get_yakuake(ksess + ' foregroundProcessId')

        cmd = ''
        if fgpid != pid:
            out = get_stdout('ps ' + fgpid, env={'PS_FORMAT': 'command'})
            cmd = out.split('\n')[-1]
        cwd = get_stdout('pwdx ' + pid).partition(' ')[2]

        tabs.append({
            'tabid': tabid,
            'sessionid': tabid,
            'title': tab_title,
            'active': sessid == activesess,
            'split': split,
            'cmd': cmd,
            'cwd': cwd,
        })

    return tabs


def format_sessions(tabs, file_path):
    cp = ConfigParser(dict_type=SortedDict)
    padding_length = len(str(len(tabs)))

    for i, tab in enumerate(tabs):
        section = 'Tab {num:{fill}{width}}'.format(
            num=i + 1, fill='0', width=padding_length
        )

        cp.add_section(section)
        cp.set(section, 'title', tab['title'])
        cp.set(section, 'active', '1' if tab['active'] else '0')
        cp.set(section, 'tab', str(tab['tabid']))
        cp.set(section, 'split', tab['split'])
        cp.set(section, 'cwd', tab['cwd'])
        cp.set(section, 'cmd', tab['cmd'])

    cp.write(file_path)


def load_sessions(file):
    cp = ConfigParser(dict_type=SortedDict)
    cp.read_file(file)

    sections = cp.sections()
    if not sections:
        print("No tab info found, aborting", file=sys.stderr)
        sys.exit(1)

    # Clear existing sessions
    subprocess.call(['killall', 'yakuake'])
    subprocess.call(['yakuake'])
    time.sleep(2)

    # Repopulate the tabs
    tab = 0
    active = 0
    for i, section in enumerate(sections):
        opts = dict(cp.items(section))
        if not opts['split']:
            tab += 1
            get_yakuake('/yakuake/sessions addSession')
            get_yakuake(
                '/yakuake/tabs setTabTitle {} "{}"'.format(tab, opts['title'])
            )
        else:
            target, split = (tab, opts['split']) if ':' not in opts['split'] \
                else opts['split'].split(':')

            get_yakuake('/yakuake/sessions splitTerminal{} {}'.format(
                {'vertical': 'LeftRight', 'horizontal': 'TopBottom'}[split],
                int(target)
            ))

        sessid = int(get_yakuake('/yakuake/tabs sessionAtTab {}'.format(i)))
        if opts['cwd']:
            get_yakuake(
                '/yakuake/sessions runCommand " cd {}"'.format(opts['cwd'])
            )

        if opts['cmd']:
            for cmd in opts['cmd'].split(r'\n'):
                dbus_session = bus.get_object(
                    'org.kde.yakuake',
                    '/Sessions/{}'.format(i + 1)
                )
                dbus_session = dbus.Interface(
                    dbus_session,
                    'org.kde.konsole.Session'
                )
                dbus_session.sendText(cmd)
                dbus_session.sendText('\n')

        if opts['active'].lower() in ['y', 'yes', 'true', '1']:
            active = sessid

    if active:
        get_yakuake('/yakuake/sessions raiseSession {}'.format(active))

    # Remove initial session
    get_yakuake('/yakuake/sessions removeSession 0')


def main():
    # TODO: also store shell environment (for virtualenvs and such)
    arg_parser = ArgumentParser(
        description="Save and load yakuake sessions. Settings are exported "
                    "in INI format. Default action is to print the current "
                    "setup to stdout in INI format."
    )

    group_exclusive = arg_parser.add_mutually_exclusive_group(required=True)

    group_exclusive.add_argument(
        '-i', '--in-file',
        help='File to read from, or "-" for stdin',
        dest='infile',
        metavar='FILE'
    )

    group_exclusive.add_argument(
        '-o', '--out-file',
        help='File to write to, or "-" for stdout',
        dest='outfile',
        metavar='FILE'
    )

    arg_parser.add_argument(
        '--force-overwrite',
        help='Do not prompt for confirmation if out-file exists',
        dest='force_overwrite',
        action="store_true",
        default=False
    )

    args = arg_parser.parse_args()

    if args.outfile is None and args.infile is None:
        format_sessions(get_sessions(), sys.stdout)
        return 0

    if args.infile is not None:
        if args.infile == '-':
            load_sessions(sys.stdin)
        elif os.path.exists(args.infile):
            file_path = open(args.infile, 'r')
            load_sessions(file_path)
        else:
            print("ERROR - Input file does not exist: '{}'".format(args.infile),
                  file=sys.stderr)
            return 1

        return 0

    if args.outfile is not None:
        if args.outfile == '-':
            format_sessions(get_sessions(), sys.stdout)
        elif not os.path.exists(args.outfile) or args.force_overwrite:
            file_path = open(args.outfile, 'w')
            format_sessions(get_sessions(), file_path)
        else:
            print("ERROR - File does already exist: '{}'".format(args.outfile),
                  file=sys.stderr)
            return 1

        return 0

    print("ERROR - Malformed arguments were passed.", file=sys.stderr)
    return 1


if __name__ == '__main__':
    sys.exit(main())
